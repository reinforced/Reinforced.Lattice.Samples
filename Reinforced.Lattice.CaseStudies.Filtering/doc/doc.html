<div class="text">
    <h2>Case</h2>
    <p>
        Table needs seaching (filtering) capabilities.
    </p>
    <h2>Necessary knowledge</h2>
    <h3>Filter types</h3>
    <p>
        Reinforced.Lattice has filters to perform filtering out non-satisfying data. It is possible to set up
        filters working on server side as well as client-side ones. Usually filters are being attached to columns,
        but there are some other use-cases. Basically, Reinforced.Lattice has 4 different types of client filters and it
        is enough since Reinforced.Lattice allows to easily customize UI and behavior:
    </p>
    <ul>
        <li>
            <b>Value filter</b> - by default exposed as textbox allowind user to input any value that he/she is looking for. It is exact filter. Being placed to particular column, filters out (removes) all rows that have corresponding column's value not equal to value put to filter.
            Actually it works in little bit different way for strings and dates
        </li>
        <li>
            <b>Select filter</b> - by default exposed as select list allowing user to select one of predefined values. Technically it is the same as value filter, but its UI allows to choose one of several predefined options to filter by
        </li>
        <li>
            <b>Multi-select filter</b> - by default exposed as multi-select list allowing user to select <i>multiple</i> of predefined values. Almost the same as select filter, but allows to change several possible values values. Row will satisfy this filter in case if corresponding column's value matches one of selected values
        </li>
        <li>
            <b>Range filter</b> - by default exposed as two textboxes placed under each others. Allows to filter out (hide) all the rows if their corresponding column's value is not in specified range.
        </li>
    </ul>
    <p>
        Using core templating, you can easily change supplied filter's UI without changing their logic.
    </p>
    <h3>Client and server filters</h3>
    <p>
        For each filter you can override server filtering criteria as well as client one.
        This process is pretty similar to <code>.Where</code> invokation even for client filtering (thanks to `{@}`-notation).
        Table <b>CAN</b> contain both client and server filters. So if you change client filter value then no additional server request will be performed.
        At the other hand, if you touch server filter then server request will happen.
        It is important to understand that <i>client filters are not bein executed on server</i>.
        So if you have table consisting of 1000 rows and 999 of them are filtered out by client filter -
        it means that 1000 records will be fetched from server.
        You can combine client and server filter and fine-tune your tables performance by that aspect.
    </p>
    <h3>Filtering strings</h3>
    <p>
        Keep in mind that by default <i>server</i> value filter being attached to string column filters out all the rows
        that doesnt have corresponding columns <b>strictly</b> equal to specified filter value.
        At the other hand, client string filter works in <b>totatlly different manner</b>: it breaks input string into words
        and tries to match substring among all the options being filtered. This behavior takes place only for strings,
        so make sure to override client filtering function or just deal with such behavior.
    </p>
    <h3>How to connect your favorite date picker</h3>
    <p>
        Value filter being attached to <code>DateTime</code> or <code>DateTime?</code> column is being automatically turned to datepicker. With lattice you can use <b>any</b> third-party datepicker framework (I prefer bootstrap datepicker).
        To connect your favorite datepicker to lattice, you have to specify datepicker instatniation methods
        within <code>Configurator&lt;,&gt;.Datepcker</code> method invokation. It consumes instance of <code>DatepickerOptions</code> object, having constructor with 4 string parameters:
    </p>
    <ul>
        <li>
            <code>createDatepicker</code>: inline JS function or function name. Reinforced.Lattice calls this function when it needs to turn UI input to datepicker. It receives <code>&lt;input&gt;</code> HTML element instance as first parameter and flag that date is nullable as 2nd parameter.
            Inside of this function implementation you have to create datepicker wrapper around specified <code>&lt;input&gt;</code> element or hide it and make your own, or whatever else. We are instantiating Bootstrap Datepicker here and also subscribe to its
            <code>changeDate</code> event, and fire <code>keyup</code> DOM event on original input - just because, Bootstrap Datepicker stops events propagation to original input.
        </li>
        <li>
            <code>putToDatepicker</code>: this function is being called when Reinforced.Lattice needs to put existing date value to the date picker. Here, as first parameter you will receive <code>&lt;input&gt;</code> element where you have to put date to and JS Date object instance
            as second parameter. You obviously have to set your date picker to specified date. Please note that passed date may be actually <code>null</code> - it depends on your column configuration
        </li>
        <li>
            <code>getFromDatePicker</code>: Reinforced.Lattice calls it when it needs to get value from datepicker. Corresponding <code>&lt;input&gt;</code> element is being passed as 1st parameter. As return, Reinforced.Lattice expects JS Date object or null
        </li>
        <li>
            <code>destroyDatepicker</code>: this function must destroy datepicker object associated with corrsponding <code>&lt;input&gt;</code> element. Reinforced.Lattice calls it to release memory from unnecessary datepicker. In order to use Bootstrap Datepicker, we call <code>$(element).datepicker('remove');</code> witin this function.
        </li>
    </ul>
</div>
<pre class="language-cshtml wrap-code" data-src="#doc#/connect-datepicker.cshtml"></pre>
<div class="text">
    <p>
        Reinforced.Lattice uses specified datepicker methods for value filter, range filter and also for editing, forms, formwatch and other places.
        So being specified once, your favorite datepicker will be used everywhere.
    </p>
    <h3>How to use <code>.AppendEmptyFilters()</code> method, what it does?</h3>
    <p>
        If you are using datagrid-like layout then you should use <code>.AppendEmptyFilters()</code> method of table configurator
        to append empty filter wrappers to layout. Withot calling of this method, filters will be appended to layout template sequentionally in order they were defined:
    </p>
    <div class="row">
        <div class="col-sm-6">
            <p class="text-center"><span style="color:#c91818"><span class="glyphicon glyphicon-remove"></span></span> Without <code>.AppendEmptyFilters</code></p>
            <div class="text-center">
                <img style="width: 100%" src="#doc#/without-appendempty.png" alt="Table with filters without AppendEmptyFilters called" />
            </div>
        </div>
        <div class="col-sm-6">
            <p class="text-center"><span style="color:#669026"><span class="glyphicon glyphicon-ok"></span></span> With <code>.AppendEmptyFilters</code></p>
            <div class="text-center">
                <img style="width: 100%" src="#doc#/with-appendempty.png" alt="Table with filters without AppendEmptyFilters called" />
            </div>
        </div>
    </div>
    <p>
        We will avoid call to <code>.AppendEmptyFilters()</code> method in "Core templating" case study when we will change table layout. But for now we will use this method
        to achieve pretty UI. If you are using built-in Bootstrap template then call this method too.
    </p>
    <h2>Solution</h2>
    <h3>How to add value filter to column</h3>
    <p>
        Select column and call <code>.FilterValue</code> method:
    </p>
</div>
<pre class="language-csharp wrap-code" data-src="#doc#/filter-value.cs"></pre>
<div class="text">
    <h3>How to add select filter to column</h3>
    <p>
        Use <code>.FilterSelect</code> method:
    </p>
</div>
<pre class="language-csharp wrap-code" data-src="#doc#/filter-select.cs"></pre>
<div class="text">
    <h3>How to customize select filter items</h3>
    <p>
        Select filter's Ui configuration has several extension methods to fullfill it with items:
    </p>
    <ul>
        <li>
            <code>.SelectItems(items, bool replaceItems = false)</code> - appends items list for select filter. It consumes <code>IEnumerable</code> of instances of special Reinforced.Lattice's internal type: <code>UiListItem</code>.
            It is almost the same as default <a href="https://msdn.microsoft.com/en-us/library/system.web.mvc.selectlistitem(v=vs.118).aspx" target="_blank">MVC's SelectListItem</a>. It is only made to make Reinforced.Lattice core
            library does not depend on MVC. <br />
            <ul>
                <li>If you are using <code>Reinforced.Lattice.Bundle.Mvc4/5</code> or <code>Reinforced.Lattice.Mvc5.Razor</code> package then there will be second overload for <code>.SelectItems</code>
                    consuming <code>IEnumerable</code> of MVC's SelectListItem so you can use both. Consider also using <code>.ToUi</code> method provided in <code>Reinforced.Lattice.Mvc5.Razor</code> to convert MVC select list items to Reinforced.Lattice's ones.</li>
                <li>Second parameter - <code>replaceItems</code> by default is <code>false</code>. When it is set to <code>true</code> then if list that you configure already has some items specified - they will be discarded and <i>replaced</i> with items passed by the first parameter.
                    So, when <code>replaceItems</code> is <code>false</code> - items will be <i>appended</i>, when <code>true</code> - items will be <i>replaced</i>.</li>
            </ul>
        </li>
        <li>
            <code>.SelectAny(bool allowAny = true,string anyText = "Any")</code> - appends "Any" item to select list options list. When user selects this item in filter's select list, it will basically disable this filter, leaving all the records from initial set.
            E.g. filter users by "any" user type will display users of all available types. <br />
            <ul>
                <li>You can specify text for "any" option using <code>anyText</code> parameter. <br /></li>
                <li>Setting <code>allowAny</code> to <code>false</code> will remove all "any" options from select list items list. <br /></li>
                <li>
                    Please also note that every option (<code>UiListItem</code>/<code>SelectListItme</code>) with <code>Value</code> set to empty string are considered as "Any" options.        
                </li>
            </ul>
        </li>
        <li>
            <code>.SelectNotPresent(bool allowNotPresent = true,string notPresentText = "Not present")</code> - only available on select UI configuration for nullable or reference-typed columns.
            Basically this option will match all the rows that have <code>null</code> value in particular column. <br />
            <ul>
                <li>"Not present" option technically equals to regular options with <code>Value</code> set to <code>Reinforced.Lattice.ValueConverter.NotPresentValue</code> that by default is equal to <code>"$$lattice_not_present$$"</code>. <br /></li>
                <li>You can specify text for "Not present" option using <code>notPresentText</code> parameter. <br /></li>
                <li>Setting <code>allowNotPresent</code> to <code>false</code> will remove all "Not present" options from select list items list. <br /></li>
            </ul>
        </li>
    </ul>
    <p>
        Invokation of several of these methods preserves order of options:
    </p>
</div>
<pre class="language-csharp wrap-code" data-src="#doc#/filter-select-options.cs"></pre>
<div class="text">
    <div class="row">
        <div class="col-sm-6">
            <p>
                In case 1 list options will be
            </p>
            <ul>
                <li>"Any"</li>
                <li>"Not present"</li>
                <li>"Admin"</li>
                <li>"Customer"</li>
            </ul>
        </div>
        <div class="col-sm-6">
            <p>
                In case 2 list options will be
            </p>
            <ul>
                <li>"Admin"</li>
                <li>"Customer"</li>
                <li>"Any"</li>
                <li>"Not present"</li>
            </ul>
        </div>
    </div>
</div>
<div class="text tiptext" data-tiptext="extension" data-caption="About Configuration extensions">
    <p>
        In Reinforced.Lattice table configurations are maintained as C# <a href="https://msdn.microsoft.com/en-us/library/bb383977.aspx" target="_blank">extension methods</a> implementing <a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank">fluent interface configuration</a>.
        So you can chain your configurations methods and therefore combine configurations obtaining new configurations. <br />
        No XML configuration, no <a href="https://datatables.net/" target="_blank">JSON configuration</a>, no <a href="https://demos.devexpress.com/MVCxGridViewDemos/" target="_blank">assigning properties</a>, even
        no <a href="https://demos.telerik.com/aspnet-mvc/grid" target="_blank">creating separate web project to enable grids</a>! Just clear, precise, chainable and maintainable fluent configuration. <br />
        Unfortunately you cannot chain configurations for cells templating, but you can do lot more other fun with them.
    </p>
</div>